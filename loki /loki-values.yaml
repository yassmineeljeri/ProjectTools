  loki:
    podAnnotations:
      azure.workload.identity/inject-proxy-sidecar: "true"
    podLabels:
      "azure.workload.identity/use": "true" # Add this label to the Loki pods to enable workload identity
    schemaConfig:
      configs:
        - from: "2024-04-01"
          store: tsdb
          object_store: azure
          schema: v13
          index:
            prefix: loki_index_
            period: 24h
    storage_config:
      azure:
        account_name: "lokistorage001"
        container_name: "chunkbucket" # Your actual Azure Blob Storage container name (loki-azure-dev-chunks)
        use_federated_token: true # Use federated token for authentication
    ingester:
      chunk_encoding: snappy
    pattern_ingester:
      enabled: true
    limits_config:
      allow_structured_metadata: true
      volume_enabled: true
      retention_period: 672h # 28 days retention
    compactor:
      retention_enabled: true
      delete_request_store: azure
    ruler:
      enable_api: true
      storage:
        type: azure
        azure:
          account_name: lokistorage001
          container_name: rulerbucket # Your actual Azure Blob Storage container name (loki-azure-dev-ruler)
          use_federated_token: true # Use federated token for authentication
        #alertmanager_url: http://prom:9093 # The URL of the Alertmanager to send alerts (Prometheus, Mimir, etc.)

    querier:
      max_concurrent: 4

    storage:
      type: azure
      bucketNames:
        chunks: "chunkbucket" # Your actual Azure Blob Storage container name (loki-azure-dev-chunks)
        ruler: "rulerbucket" # Your actual Azure Blob Storage container name (loki-azure-dev-ruler)
        # admin: "admin-loki-devrel" # Your actual Azure Blob Storage container name (loki-azure-dev-admin)
      azure:
        accountName: lokistorage001
        useFederatedToken: true # Use federated token for authentication

  # Define the Azure workload identity
  serviceAccount:
    name: loki
    annotations:
      azure.workload.identity/client-id: d8968b18-b2a8-460b-83ba-0edf3d46d153

  deploymentMode: Distributed

  ingester:
    replicas: 2
    zoneAwareReplication:
      enabled: false

  querier:
    replicas: 1
    maxUnavailable: 1

  queryFrontend:
    replicas: 1
    maxUnavailable: 1

  queryScheduler:
    replicas: 1

  distributor:
    replicas: 1
    maxUnavailable: 1
  compactor:
    replicas: 1

  indexGateway:
    replicas: 1
    maxUnavailable: 1

  ruler:
    replicas: 1
    maxUnavailable: 1


  # This exposes the Loki gateway so it can be written to and queried externaly
  gateway:
    service:
      type: ClusterIP
    basicAuth:
      enabled: true
      existingSecret: loki-basic-auth
      htpasswdFile: .htpasswd
    ingress:
      enabled: false
#
#      true
#      ingressClassName: nginx
#      annotations:
#        nginx.ingress.kubernetes.io/ssl-redirect: "true"
#      hosts:
#        - host: grafanaloki.devops-tool.com
#          paths:
#            - path: /
#              pathType: Prefix
#      tls:
#        - hosts:
#            - grafanaloki.devops-tool.com
#          secretName: tls-grafana-loki-kv



  # Since we are using basic auth, we need to pass the username and password to the canary
  lokiCanary:
    extraArgs:
      - -pass=$(LOKI_PASS)
      - -user=$(LOKI_USER)
    extraEnv:
      - name: LOKI_PASS
        valueFrom:
          secretKeyRef:
            name: canary-basic-auth
            key: password
      - name: LOKI_USER
        valueFrom:
          secretKeyRef:
            name: canary-basic-auth
            key: username

  # Enable minio for storage
  minio:
    enabled: false

  backend:
    replicas: 0
  read:
    replicas: 0
  write:
    replicas: 0

  singleBinary:
    replicas: 0